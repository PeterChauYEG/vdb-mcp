#!/bin/bash
# Shared library functions for setup scripts

# Output
print_header() { echo -e "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  $1\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"; }
print_step() { echo -e "[$1/5] $2\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"; }
print_success() { echo "âœ… $1"; }
print_error() { echo "âŒ Error: $1" >&2; }
print_warning() { echo "âš ï¸  Warning: $1"; }
print_info() { echo "   $1"; }

# Path utilities
validate_codebase() { [ -d "$1" ] || { print_error "Directory not found: $1"; exit 1; }; }
get_absolute_path() { (cd "$1" && pwd); }
get_collection_name() { basename "$1"; }
get_git_hash() { [ -d "$1/.git" ] && (cd "$1" && git rev-parse HEAD 2>/dev/null) || echo ""; }
get_git_branch() { [ -d "$1/.git" ] && (cd "$1" && git rev-parse --abbrev-ref HEAD 2>/dev/null) || echo ""; }

# Configuration
create_env_file() {
    local project_root="$(cd "$SCRIPT_DIR" && pwd)"
    cat > "$project_root/.env" << EOF
CODEBASE_PATH=$1
COLLECTION_NAME=$2
GIT_HASH=$3
GIT_BRANCH=$4
EOF
}

# Indexing
start_indexing() {
    local project_root="$(cd "$SCRIPT_DIR" && pwd)"
    mkdir -p "$project_root/data/chroma"
    chmod 777 "$project_root/data/chroma" 2>/dev/null || true
    (cd "$project_root" && docker compose --profile index down > /dev/null 2>&1)
    (cd "$project_root" && docker compose up -d chromadb > /dev/null 2>&1)
    (cd "$project_root" && docker compose --profile index up -d embedding > /dev/null 2>&1)
    print_info "Waiting for ChromaDB and embedding service..."
    sleep 15
    (cd "$project_root" && docker compose --profile index up -d indexer > /dev/null 2>&1)
}

wait_for_indexing() {
    local project_root="$(cd "$SCRIPT_DIR" && pwd)"
    print_info "Waiting for indexer to start..."
    local waited=0
    while [ $waited -lt 30 ]; do
        docker ps -a --format "{{.Names}}" | grep -q "vector-mcp-indexer" && break
        sleep 1; waited=$((waited + 1))
    done
    docker ps -a --format "{{.Names}}" | grep -q "vector-mcp-indexer" || { print_warning "Indexer container not found"; return 1; }
    echo ""; print_info "Indexing progress:"; echo ""
    docker logs -f vector-mcp-indexer 2>&1 | while IFS= read -r line; do
        echo "$line" | grep -qE "^===|Directory:|Collection:|Git |Connecting|Created|Using existing|Scanning|Found|Processing|Processed|Generated|Embedding|batch|Total|Branch|Commit|already indexed|TEI|Indexing" && echo "   $line"
    done
    local exit_code=$(docker inspect vector-mcp-indexer --format='{{.State.ExitCode}}' 2>/dev/null || echo "1")
    echo ""
    [ "$exit_code" = "0" ] && { print_success "Indexing complete!"; return 0; } || { print_error "Indexer failed with exit code: $exit_code"; return 1; }
}

cleanup_indexing_services() {
    local project_root="$(cd "$SCRIPT_DIR" && pwd)"
    (cd "$project_root" && docker compose --profile index stop embedding indexer > /dev/null 2>&1)
    (cd "$project_root" && docker compose --profile index rm -f embedding indexer > /dev/null 2>&1)
}

# Claude Code Configuration
configure_claude() {
    local project_root="$(cd "$SCRIPT_DIR" && pwd)"
    local mcp_config="$1/.mcp.json"
    local mcp_server_script="$project_root/mcp-server.sh"
    [ -f "$mcp_server_script" ] || { print_error "mcp-server.sh not found"; return 1; }
    chmod +x "$mcp_server_script"
    [ -f "$mcp_config" ] && { cp "$mcp_config" "$mcp_config.backup-$(date +%Y%m%d-%H%M%S)"; print_info "Backed up existing config"; }
    if [ -f "$mcp_config" ]; then
        python3 << PYEOF
import json
with open('$mcp_config', 'r') as f: config = json.load(f)
config.setdefault('mcpServers', {})['vector-search'] = {'type': 'stdio', 'command': '$mcp_server_script', 'args': [], 'env': {}}
with open('$mcp_config', 'w') as f: json.dump(config, f, indent=2)
PYEOF
    else
        cat > "$mcp_config" << EOF
{"mcpServers": {"vector-search": {"type": "stdio", "command": "$mcp_server_script", "args": [], "env": {}}}}
EOF
    fi
}

# Git Hooks
HOOK_VERSION="3"

hooks_need_update() {
    for hook_name in post-commit post-merge post-checkout; do
        local hook_path="$1/.git/hooks/$hook_name"
        [ -f "$hook_path" ] || return 0
        if grep -q "Auto-generated by vector-mcp" "$hook_path" 2>/dev/null; then
            local v=$(grep "HOOK_VERSION=" "$hook_path" 2>/dev/null | sed 's/.*HOOK_VERSION=//' | tr -d '"')
            [ "$v" != "$HOOK_VERSION" ] && return 0
        else
            return 0
        fi
    done
    return 1
}

install_git_hooks() {
    local codebase_path="$1"
    local project_root="$(cd "$SCRIPT_DIR" && pwd)"
    local installed=0
    for hook_name in post-commit post-merge post-checkout; do
        local hook_path="$codebase_path/.git/hooks/$hook_name"
        if [ -f "$hook_path" ]; then
            if grep -q "Auto-generated by vector-mcp" "$hook_path" 2>/dev/null; then
                local v=$(grep "HOOK_VERSION=" "$hook_path" 2>/dev/null | sed 's/.*HOOK_VERSION=//' | tr -d '"')
                [ "$v" = "$HOOK_VERSION" ] && continue
                local total=$(wc -l < "$hook_path")
                local vmp=$(grep -c "vector-mcp\|MCP_ROOT\|Re-indexing\|HOOK_VERSION" "$hook_path" 2>/dev/null || echo 0)
                [ "$vmp" -gt $((total - 5)) ] && { create_git_hook "$hook_path" "$project_root"; installed=$((installed + 1)); continue; }
                print_info "$hook_name has custom code, skipping"; continue
            fi
            echo ""; echo "âš ï¸  Existing $hook_name hook detected"
            read -p "Backup and append? (y/N) " -n 1 -r; echo ""
            [[ $REPLY =~ ^[Yy]$ ]] || { print_info "Skipped $hook_name"; continue; }
            cp "$hook_path" "$hook_path.backup-$(date +%Y%m%d-%H%M%S)"
            append_hook_code "$hook_path" "$project_root"
            installed=$((installed + 1))
        else
            create_git_hook "$hook_path" "$project_root"
            installed=$((installed + 1))
        fi
    done
    [ $installed -gt 0 ] && { print_info "Installed $installed git hooks (post-commit, post-merge, post-checkout)"; return 0; } || return 1
}

append_hook_code() {
    cat >> "$1" << EOHOOK

# Auto-generated by vector-mcp | HOOK_VERSION=$HOOK_VERSION
MCP_ROOT="$2"
[ -d "\$MCP_ROOT" ] && {
    echo "ðŸ”„ Vector MCP: Re-indexing..."
    H=\$(git rev-parse HEAD); B=\$(git rev-parse --abbrev-ref HEAD)
    [ -f "\$MCP_ROOT/.env" ] && { sed -i.bak "s|^GIT_HASH=.*|GIT_HASH=\$H|" "\$MCP_ROOT/.env"; sed -i.bak "s|^GIT_BRANCH=.*|GIT_BRANCH=\$B|" "\$MCP_ROOT/.env"; rm -f "\$MCP_ROOT/.env.bak"; }
    (cd "\$MCP_ROOT" && docker compose up -d chromadb && docker compose --profile index up -d embedding indexer > /dev/null 2>&1 &)
}
EOHOOK
}

create_git_hook() {
    cat > "$1" << EOF
#!/bin/bash
# Auto-generated by vector-mcp | HOOK_VERSION=$HOOK_VERSION
MCP_ROOT="$2"
echo "ðŸ”„ Vector MCP: Re-indexing codebase..."
H=\$(git rev-parse HEAD); B=\$(git rev-parse --abbrev-ref HEAD)
[ -f "\$MCP_ROOT/.env" ] && { sed -i.bak "s|^GIT_HASH=.*|GIT_HASH=\$H|" "\$MCP_ROOT/.env"; sed -i.bak "s|^GIT_BRANCH=.*|GIT_BRANCH=\$B|" "\$MCP_ROOT/.env"; rm -f "\$MCP_ROOT/.env.bak"; }
(cd "\$MCP_ROOT" && docker compose up -d chromadb && docker compose --profile index up -d embedding indexer > /dev/null 2>&1 &)
EOF
    chmod +x "$1"
}
